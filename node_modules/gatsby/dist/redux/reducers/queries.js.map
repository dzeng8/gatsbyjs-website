{"version":3,"sources":["../../../src/redux/reducers/queries.ts"],"names":["FLAG_DIRTY_PAGE","FLAG_DIRTY_TEXT","FLAG_DIRTY_DATA","FLAG_ERROR_EXTRACTION","initialState","byNode","Map","byConnection","trackedQueries","trackedComponents","deletedQueries","Set","initialQueryState","dirty","initialComponentState","componentPath","query","pages","errors","queriesReducer","state","action","type","path","payload","get","contextModified","registerQuery","setFlag","registerComponent","add","delete","apiName","queryId","component","values","nodeQueries","connectionQueries","clear","hasFlag","forEach","set","id","nodeId","connection","queryIds","node","queriesByNode","queriesByConnection","internal","allFlags","flag"],"mappings":"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","sourcesContent":["import {\n  ActionsUnion,\n  IComponentState,\n  IGatsbyState,\n  IQueryState,\n} from \"../types\"\n\ntype QueryId = string // page query path or static query id\ntype ComponentPath = string\ntype NodeId = string\ntype ConnectionName = string\n\nexport const FLAG_DIRTY_PAGE = 0b0001\nexport const FLAG_DIRTY_TEXT = 0b0010\nexport const FLAG_DIRTY_DATA = 0b0100\n\nexport const FLAG_ERROR_EXTRACTION = 0b0001\n\nconst initialState = (): IGatsbyState[\"queries\"] => {\n  return {\n    byNode: new Map<NodeId, Set<QueryId>>(),\n    byConnection: new Map<ConnectionName, Set<QueryId>>(),\n    trackedQueries: new Map<QueryId, IQueryState>(),\n    trackedComponents: new Map<ComponentPath, IComponentState>(),\n    deletedQueries: new Set<QueryId>(),\n  }\n}\n\nconst initialQueryState = (): IQueryState => {\n  return {\n    dirty: -1, // unknown, must be set right after init\n  }\n}\n\nconst initialComponentState = (): IComponentState => {\n  return {\n    componentPath: ``,\n    query: ``,\n    pages: new Set<QueryId>(),\n    errors: 0,\n    // TODO: staticQueries: new Set<QueryId>()\n  }\n}\n\n/**\n * Tracks query dirtiness. Dirty queries are queries that:\n *\n * - depend on nodes or node collections (via `actions.createPageDependency`) that have changed.\n * - have been recently extracted (or their query text has changed)\n * - belong to newly created pages (or pages with modified context)\n *\n * Dirty queries must be re-ran.\n */\nexport function queriesReducer(\n  state: IGatsbyState[\"queries\"] = initialState(),\n  action: ActionsUnion\n): IGatsbyState[\"queries\"] {\n  switch (action.type) {\n    case `DELETE_CACHE`:\n      return initialState()\n\n    case `CREATE_PAGE`: {\n      const { path, componentPath } = action.payload\n      let query = state.trackedQueries.get(path)\n      if (!query || action.contextModified) {\n        query = registerQuery(state, path)\n        query.dirty = setFlag(query.dirty, FLAG_DIRTY_PAGE)\n      }\n      registerComponent(state, componentPath).pages.add(path)\n      state.deletedQueries.delete(path)\n      return state\n    }\n    case `DELETE_PAGE`: {\n      // Don't actually remove the page query from trackedQueries, just mark it as \"deleted\". Why?\n      //   We promote a technique of a consecutive deletePage/createPage calls in onCreatePage hook,\n      //   see https://www.gatsbyjs.com/docs/creating-and-modifying-pages/#pass-context-to-pages\n      //   If we remove a query and then re-add, it will be marked as dirty.\n      //   This is OK for cold cache but with warm cache we will re-run all of those queries (unnecessarily).\n      //   We will reconcile the state after createPages API call and actually delete those queries.\n      state.deletedQueries.add(action.payload.path)\n      return state\n    }\n    case `API_FINISHED`: {\n      if (action.payload.apiName !== `createPages`) {\n        return state\n      }\n      for (const queryId of state.deletedQueries) {\n        for (const component of state.trackedComponents.values()) {\n          component.pages.delete(queryId)\n        }\n        for (const nodeQueries of state.byNode.values()) {\n          nodeQueries.delete(queryId)\n        }\n        for (const connectionQueries of state.byConnection.values()) {\n          connectionQueries.delete(queryId)\n        }\n        state.trackedQueries.delete(queryId)\n      }\n      state.deletedQueries.clear()\n      return state\n    }\n    case `QUERY_EXTRACTED`: {\n      // Note: this action is called even in case of\n      // extraction error or missing query (with query === ``)\n      // TODO: use hash instead of a query text\n      const { componentPath, query } = action.payload\n      const component = registerComponent(state, componentPath)\n      if (hasFlag(component.errors, FLAG_ERROR_EXTRACTION)) {\n        return state\n      }\n      if (component.query !== query) {\n        // Invalidate all pages associated with a component when query text changes\n        component.pages.forEach(queryId => {\n          const query = state.trackedQueries.get(queryId)\n          if (query) {\n            query.dirty = setFlag(query.dirty, FLAG_DIRTY_TEXT)\n          }\n        })\n        component.query = query\n      }\n      return state\n    }\n    case `QUERY_EXTRACTION_GRAPHQL_ERROR`:\n    case `QUERY_EXTRACTION_BABEL_ERROR`:\n    case `QUERY_EXTRACTION_BABEL_SUCCESS`: {\n      const { componentPath } = action.payload\n      const component = registerComponent(state, componentPath)\n      const set = action.type !== `QUERY_EXTRACTION_BABEL_SUCCESS`\n      component.errors = setFlag(component.errors, FLAG_ERROR_EXTRACTION, set)\n      return state\n    }\n    case `REPLACE_STATIC_QUERY`: {\n      // Only called when static query text has changed, so no need to compare\n      // TODO: unify the behavior?\n      const query = registerQuery(state, action.payload.id)\n      query.dirty = setFlag(query.dirty, FLAG_DIRTY_TEXT)\n      state.deletedQueries.delete(action.payload.id)\n      return state\n    }\n    case `REMOVE_STATIC_QUERY`: {\n      state.deletedQueries.add(action.payload)\n      return state\n    }\n    case `CREATE_COMPONENT_DEPENDENCY`: {\n      const { path: queryId, nodeId, connection } = action.payload\n      if (nodeId) {\n        const queryIds = state.byNode.get(nodeId) ?? new Set<QueryId>()\n        queryIds.add(queryId)\n        state.byNode.set(nodeId, queryIds)\n      }\n      if (connection) {\n        const queryIds =\n          state.byConnection.get(connection) ?? new Set<QueryId>()\n        queryIds.add(queryId)\n        state.byConnection.set(connection, queryIds)\n      }\n      return state\n    }\n    case `QUERY_START`: {\n      // Reset data dependencies as they will be updated when running the query\n      const { path } = action.payload\n      state.byNode.forEach(queryIds => {\n        queryIds.delete(path)\n      })\n      state.byConnection.forEach(queryIds => {\n        queryIds.delete(path)\n      })\n      return state\n    }\n    case `CREATE_NODE`:\n    case `DELETE_NODE`: {\n      const node = action.payload\n      if (!node) {\n        return state\n      }\n      const queriesByNode = state.byNode.get(node.id) ?? []\n      const queriesByConnection =\n        state.byConnection.get(node.internal.type) ?? []\n\n      queriesByNode.forEach(queryId => {\n        const query = state.trackedQueries.get(queryId)\n        if (query) {\n          query.dirty = setFlag(query.dirty, FLAG_DIRTY_DATA)\n        }\n      })\n      queriesByConnection.forEach(queryId => {\n        const query = state.trackedQueries.get(queryId)\n        if (query) {\n          query.dirty = setFlag(query.dirty, FLAG_DIRTY_DATA)\n        }\n      })\n      return state\n    }\n    case `PAGE_QUERY_RUN`: {\n      const { path } = action.payload\n      const query = registerQuery(state, path)\n      query.dirty = 0\n      return state\n    }\n    default:\n      return state\n  }\n}\n\nfunction setFlag(allFlags: number, flag: number, set = true): number {\n  if (allFlags < 0) {\n    allFlags = 0\n  }\n  return set ? allFlags | flag : allFlags & ~flag\n}\n\nexport function hasFlag(allFlags: number, flag: number): boolean {\n  return allFlags >= 0 && (allFlags & flag) > 0\n}\n\nfunction registerQuery(\n  state: IGatsbyState[\"queries\"],\n  queryId: QueryId\n): IQueryState {\n  let query = state.trackedQueries.get(queryId)\n  if (!query) {\n    query = initialQueryState()\n    state.trackedQueries.set(queryId, query)\n  }\n  return query\n}\n\nfunction registerComponent(\n  state: IGatsbyState[\"queries\"],\n  componentPath: string\n): IComponentState {\n  let component = state.trackedComponents.get(componentPath)\n  if (!component) {\n    component = initialComponentState()\n    component.componentPath = componentPath\n    state.trackedComponents.set(componentPath, component)\n  }\n  return component\n}\n"],"file":"queries.js"}