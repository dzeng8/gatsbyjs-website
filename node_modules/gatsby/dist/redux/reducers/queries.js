"use strict";

exports.__esModule = true;
exports.queriesReducer = queriesReducer;
exports.hasFlag = hasFlag;
exports.FLAG_ERROR_EXTRACTION = exports.FLAG_DIRTY_DATA = exports.FLAG_DIRTY_TEXT = exports.FLAG_DIRTY_PAGE = void 0;
// page query path or static query id
const FLAG_DIRTY_PAGE = 0b0001;
exports.FLAG_DIRTY_PAGE = FLAG_DIRTY_PAGE;
const FLAG_DIRTY_TEXT = 0b0010;
exports.FLAG_DIRTY_TEXT = FLAG_DIRTY_TEXT;
const FLAG_DIRTY_DATA = 0b0100;
exports.FLAG_DIRTY_DATA = FLAG_DIRTY_DATA;
const FLAG_ERROR_EXTRACTION = 0b0001;
exports.FLAG_ERROR_EXTRACTION = FLAG_ERROR_EXTRACTION;

const initialState = () => {
  return {
    byNode: new Map(),
    byConnection: new Map(),
    trackedQueries: new Map(),
    trackedComponents: new Map(),
    deletedQueries: new Set()
  };
};

const initialQueryState = () => {
  return {
    dirty: -1 // unknown, must be set right after init

  };
};

const initialComponentState = () => {
  return {
    componentPath: ``,
    query: ``,
    pages: new Set(),
    errors: 0 // TODO: staticQueries: new Set<QueryId>()

  };
};
/**
 * Tracks query dirtiness. Dirty queries are queries that:
 *
 * - depend on nodes or node collections (via `actions.createPageDependency`) that have changed.
 * - have been recently extracted (or their query text has changed)
 * - belong to newly created pages (or pages with modified context)
 *
 * Dirty queries must be re-ran.
 */


function queriesReducer(state = initialState(), action) {
  switch (action.type) {
    case `DELETE_CACHE`:
      return initialState();

    case `CREATE_PAGE`:
      {
        const {
          path,
          componentPath
        } = action.payload;
        let query = state.trackedQueries.get(path);

        if (!query || action.contextModified) {
          query = registerQuery(state, path);
          query.dirty = setFlag(query.dirty, FLAG_DIRTY_PAGE);
        }

        registerComponent(state, componentPath).pages.add(path);
        state.deletedQueries.delete(path);
        return state;
      }

    case `DELETE_PAGE`:
      {
        // Don't actually remove the page query from trackedQueries, just mark it as "deleted". Why?
        //   We promote a technique of a consecutive deletePage/createPage calls in onCreatePage hook,
        //   see https://www.gatsbyjs.com/docs/creating-and-modifying-pages/#pass-context-to-pages
        //   If we remove a query and then re-add, it will be marked as dirty.
        //   This is OK for cold cache but with warm cache we will re-run all of those queries (unnecessarily).
        //   We will reconcile the state after createPages API call and actually delete those queries.
        state.deletedQueries.add(action.payload.path);
        return state;
      }

    case `API_FINISHED`:
      {
        if (action.payload.apiName !== `createPages`) {
          return state;
        }

        for (const queryId of state.deletedQueries) {
          for (const component of state.trackedComponents.values()) {
            component.pages.delete(queryId);
          }

          for (const nodeQueries of state.byNode.values()) {
            nodeQueries.delete(queryId);
          }

          for (const connectionQueries of state.byConnection.values()) {
            connectionQueries.delete(queryId);
          }

          state.trackedQueries.delete(queryId);
        }

        state.deletedQueries.clear();
        return state;
      }

    case `QUERY_EXTRACTED`:
      {
        // Note: this action is called even in case of
        // extraction error or missing query (with query === ``)
        // TODO: use hash instead of a query text
        const {
          componentPath,
          query
        } = action.payload;
        const component = registerComponent(state, componentPath);

        if (hasFlag(component.errors, FLAG_ERROR_EXTRACTION)) {
          return state;
        }

        if (component.query !== query) {
          // Invalidate all pages associated with a component when query text changes
          component.pages.forEach(queryId => {
            const query = state.trackedQueries.get(queryId);

            if (query) {
              query.dirty = setFlag(query.dirty, FLAG_DIRTY_TEXT);
            }
          });
          component.query = query;
        }

        return state;
      }

    case `QUERY_EXTRACTION_GRAPHQL_ERROR`:
    case `QUERY_EXTRACTION_BABEL_ERROR`:
    case `QUERY_EXTRACTION_BABEL_SUCCESS`:
      {
        const {
          componentPath
        } = action.payload;
        const component = registerComponent(state, componentPath);
        const set = action.type !== `QUERY_EXTRACTION_BABEL_SUCCESS`;
        component.errors = setFlag(component.errors, FLAG_ERROR_EXTRACTION, set);
        return state;
      }

    case `REPLACE_STATIC_QUERY`:
      {
        // Only called when static query text has changed, so no need to compare
        // TODO: unify the behavior?
        const query = registerQuery(state, action.payload.id);
        query.dirty = setFlag(query.dirty, FLAG_DIRTY_TEXT);
        state.deletedQueries.delete(action.payload.id);
        return state;
      }

    case `REMOVE_STATIC_QUERY`:
      {
        state.deletedQueries.add(action.payload);
        return state;
      }

    case `CREATE_COMPONENT_DEPENDENCY`:
      {
        const {
          path: queryId,
          nodeId,
          connection
        } = action.payload;

        if (nodeId) {
          var _state$byNode$get;

          const queryIds = (_state$byNode$get = state.byNode.get(nodeId)) !== null && _state$byNode$get !== void 0 ? _state$byNode$get : new Set();
          queryIds.add(queryId);
          state.byNode.set(nodeId, queryIds);
        }

        if (connection) {
          var _state$byConnection$g;

          const queryIds = (_state$byConnection$g = state.byConnection.get(connection)) !== null && _state$byConnection$g !== void 0 ? _state$byConnection$g : new Set();
          queryIds.add(queryId);
          state.byConnection.set(connection, queryIds);
        }

        return state;
      }

    case `QUERY_START`:
      {
        // Reset data dependencies as they will be updated when running the query
        const {
          path
        } = action.payload;
        state.byNode.forEach(queryIds => {
          queryIds.delete(path);
        });
        state.byConnection.forEach(queryIds => {
          queryIds.delete(path);
        });
        return state;
      }

    case `CREATE_NODE`:
    case `DELETE_NODE`:
      {
        var _state$byNode$get2, _state$byConnection$g2;

        const node = action.payload;

        if (!node) {
          return state;
        }

        const queriesByNode = (_state$byNode$get2 = state.byNode.get(node.id)) !== null && _state$byNode$get2 !== void 0 ? _state$byNode$get2 : [];
        const queriesByConnection = (_state$byConnection$g2 = state.byConnection.get(node.internal.type)) !== null && _state$byConnection$g2 !== void 0 ? _state$byConnection$g2 : [];
        queriesByNode.forEach(queryId => {
          const query = state.trackedQueries.get(queryId);

          if (query) {
            query.dirty = setFlag(query.dirty, FLAG_DIRTY_DATA);
          }
        });
        queriesByConnection.forEach(queryId => {
          const query = state.trackedQueries.get(queryId);

          if (query) {
            query.dirty = setFlag(query.dirty, FLAG_DIRTY_DATA);
          }
        });
        return state;
      }

    case `PAGE_QUERY_RUN`:
      {
        const {
          path
        } = action.payload;
        const query = registerQuery(state, path);
        query.dirty = 0;
        return state;
      }

    default:
      return state;
  }
}

function setFlag(allFlags, flag, set = true) {
  if (allFlags < 0) {
    allFlags = 0;
  }

  return set ? allFlags | flag : allFlags & ~flag;
}

function hasFlag(allFlags, flag) {
  return allFlags >= 0 && (allFlags & flag) > 0;
}

function registerQuery(state, queryId) {
  let query = state.trackedQueries.get(queryId);

  if (!query) {
    query = initialQueryState();
    state.trackedQueries.set(queryId, query);
  }

  return query;
}

function registerComponent(state, componentPath) {
  let component = state.trackedComponents.get(componentPath);

  if (!component) {
    component = initialComponentState();
    component.componentPath = componentPath;
    state.trackedComponents.set(componentPath, component);
  }

  return component;
}
//# sourceMappingURL=queries.js.map