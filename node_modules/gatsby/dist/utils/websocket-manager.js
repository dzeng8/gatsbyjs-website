"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.websocketManager = exports.WebsocketManager = void 0;

var _path2 = _interopRequireDefault(require("path"));

var _redux = require("../redux");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _pageData = require("../utils/page-data");

var _gatsbyTelemetry = _interopRequireDefault(require("gatsby-telemetry"));

var _url = _interopRequireDefault(require("url"));

var _crypto = require("crypto");

var _findPageByPath = require("./find-page-by-path");

var _socket = _interopRequireDefault(require("socket.io"));

/* eslint-disable no-invalid-this */

/**
 * Get page query result for given page path.
 * @param {string} pagePath Path to a page.
 */
async function getPageData(pagePath) {
  const state = _redux.store.getState();

  const publicDir = _path2.default.join(state.program.directory, `public`);

  const result = {
    id: pagePath,
    result: undefined
  };
  const page = (0, _findPageByPath.findPageByPath)(state, pagePath);

  if (page) {
    result.id = page.path;

    try {
      const pageData = await (0, _pageData.readPageData)(publicDir, page.path);
      result.result = pageData;
    } catch (err) {
      throw new Error(`Error loading a result for the page query in "${pagePath}". Query was not run and no cached result was found.`);
    }
  }

  return result;
}
/**
 * Get page query result for given page path.
 * @param {string} pagePath Path to a page.
 */


async function getStaticQueryData(staticQueryId) {
  const {
    program
  } = _redux.store.getState();

  const publicDir = _path2.default.join(program.directory, `public`);

  const filePath = _path2.default.join(publicDir, `page-data`, `sq`, `d`, `${staticQueryId}.json`);

  const result = {
    id: staticQueryId,
    result: undefined
  };

  if (await _fsExtra.default.pathExists(filePath)) {
    try {
      const fileResult = await _fsExtra.default.readJson(filePath);
      result.result = fileResult;
    } catch (err) {// ignore errors
    }
  }

  return result;
}

function hashPaths(paths) {
  return paths.map(path => (0, _crypto.createHash)(`sha256`).update(path).digest(`hex`));
}

class WebsocketManager {
  constructor() {
    this.activePaths = new Set();
    this.clients = new Set();
    this.errors = new Map();
    this.pageResults = new Map();
    this.staticQueryResults = new Map();

    this.init = ({
      server
    }) => {
      this.websocket = (0, _socket.default)(server, {
        // we see ping-pong timeouts on gatsby-cloud when socket.io is running for a while
        // increasing it should help
        // @see https://github.com/socketio/socket.io/issues/3259#issuecomment-448058937
        pingTimeout: 30000
      });

      const updateServerActivePaths = () => {
        const serverActivePaths = new Set();

        for (const client of this.clients) {
          if (client.activePath) {
            serverActivePaths.add(client.activePath);
          }
        }

        this.activePaths = serverActivePaths;
      };

      this.websocket.on(`connection`, socket => {
        var _socket$handshake, _socket$handshake$hea;

        const clientInfo = {
          activePath: null,
          socket
        };
        this.clients.add(clientInfo);

        const setActivePath = (newActivePath, fallbackTo404 = false) => {
          let activePagePath = null;

          if (newActivePath) {
            const page = (0, _findPageByPath.findPageByPath)(_redux.store.getState(), newActivePath, fallbackTo404);

            if (page) {
              activePagePath = page.path;
            }
          }

          clientInfo.activePath = activePagePath;
          updateServerActivePaths();
        };

        if (socket === null || socket === void 0 ? void 0 : (_socket$handshake = socket.handshake) === null || _socket$handshake === void 0 ? void 0 : (_socket$handshake$hea = _socket$handshake.headers) === null || _socket$handshake$hea === void 0 ? void 0 : _socket$handshake$hea.referer) {
          const path = _url.default.parse(socket.handshake.headers.referer).path;

          setActivePath(path, true);
        }

        this.errors.forEach((message, errorID) => {
          socket.send({
            type: `overlayError`,
            payload: {
              id: errorID,
              message
            }
          });
        });

        const getDataForPath = async path => {
          var _pageData$result$stat, _pageData$result;

          const page = (0, _findPageByPath.findPageByPath)(_redux.store.getState(), path);

          if (!page) {
            socket.send({
              type: `pageQueryResult`,
              why: `getDataForPath-notfound`,
              payload: {
                id: path,
                result: undefined
              }
            });
            return;
          }

          path = page.path;
          let pageData = this.pageResults.get(path);

          if (!pageData) {
            try {
              pageData = await getPageData(path);
              this.pageResults.set(path, pageData);
            } catch (err) {
              console.log(err.message);
              return;
            }
          }

          const staticQueryHashes = (_pageData$result$stat = (_pageData$result = pageData.result) === null || _pageData$result === void 0 ? void 0 : _pageData$result.staticQueryHashes) !== null && _pageData$result$stat !== void 0 ? _pageData$result$stat : [];
          await Promise.all(staticQueryHashes.map(async queryId => {
            let staticQueryResult = this.staticQueryResults.get(queryId);

            if (!staticQueryResult) {
              staticQueryResult = await getStaticQueryData(queryId);
              this.staticQueryResults.set(queryId, staticQueryResult);
            }

            socket.send({
              type: `staticQueryResult`,
              payload: staticQueryResult
            });
          }));
          socket.send({
            type: `pageQueryResult`,
            why: `getDataForPath`,
            payload: pageData
          });

          if (this.clients.size > 0) {
            _gatsbyTelemetry.default.trackCli(`WEBSOCKET_PAGE_DATA_UPDATE`, {
              siteMeasurements: {
                clientsCount: this.clients.size,
                paths: hashPaths(Array.from(this.activePaths))
              }
            }, {
              debounce: true
            });
          }
        };

        socket.on(`getDataForPath`, getDataForPath);
        socket.on(`registerPath`, path => {
          setActivePath(path, true);
        });
        socket.on(`disconnect`, () => {
          setActivePath(null);
          this.clients.delete(clientInfo);
        });
        socket.on(`unregisterPath`, _path => {
          setActivePath(null);
        });
      });
      return this.websocket;
    };

    this.getSocket = () => this.websocket;

    this.emitStaticQueryData = data => {
      this.staticQueryResults.set(data.id, data);

      if (this.websocket) {
        this.websocket.send({
          type: `staticQueryResult`,
          payload: data
        });

        if (this.clients.size > 0) {
          _gatsbyTelemetry.default.trackCli(`WEBSOCKET_EMIT_STATIC_PAGE_DATA_UPDATE`, {
            siteMeasurements: {
              clientsCount: this.clients.size,
              paths: hashPaths(Array.from(this.activePaths))
            }
          }, {
            debounce: true
          });
        }
      }
    };

    this.emitPageData = data => {
      this.pageResults.set(data.id, data);

      if (this.websocket) {
        this.websocket.send({
          type: `pageQueryResult`,
          payload: data
        });

        if (this.clients.size > 0) {
          _gatsbyTelemetry.default.trackCli(`WEBSOCKET_EMIT_PAGE_DATA_UPDATE`, {
            siteMeasurements: {
              clientsCount: this.clients.size,
              paths: hashPaths(Array.from(this.activePaths))
            }
          }, {
            debounce: true
          });
        }
      }
    };

    this.emitError = (id, message) => {
      if (message) {
        this.errors.set(id, message);
      } else {
        this.errors.delete(id);
      }

      if (this.websocket) {
        this.websocket.send({
          type: `overlayError`,
          payload: {
            id,
            message
          }
        });
      }
    };
  }

}

exports.WebsocketManager = WebsocketManager;
const websocketManager = new WebsocketManager();
exports.websocketManager = websocketManager;
//# sourceMappingURL=websocket-manager.js.map